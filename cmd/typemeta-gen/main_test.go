package main

import (
	"bytes"
	"io"
	"log"
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/mike-jacks/typemeta"
)

func setupTest(t *testing.T) (string, func()) {
	tmpDir, err := os.MkdirTemp("", "typemeta-test-*")
	if err != nil {
		t.Fatalf("Failed to create temp dir: %v", err)
	}
	return tmpDir, func() { os.RemoveAll(tmpDir) }
}

func createTestFile(t *testing.T, dir, filename, content string) {
	path := filepath.Join(dir, filename)
	if err := os.WriteFile(path, []byte(content), 0644); err != nil {
		t.Fatalf("Failed to create test file: %v", err)
	}
}

func captureOutput(f func()) (string, string) {
	oldStdout := os.Stdout
	oldStderr := os.Stderr
	oldLogOutput := log.Writer()
	rOut, wOut, _ := os.Pipe()
	rErr, wErr, _ := os.Pipe()
	var logBuf bytes.Buffer
	os.Stdout = wOut
	os.Stderr = wErr
	log.SetOutput(&logBuf)
	f()
	wOut.Close()
	wErr.Close()
	os.Stdout = oldStdout
	os.Stderr = oldStderr
	log.SetOutput(oldLogOutput)
	var outBuf, errBuf bytes.Buffer
	outBuf.ReadFrom(rOut)
	errBuf.ReadFrom(rErr)
	return outBuf.String(), errBuf.String() + logBuf.String()
}

func TestRun_HelpFlag(t *testing.T) {
	stdout, stderr := captureOutput(func() {
		err := run(true, "")
		if err != nil {
			t.Errorf("Expected no error for help flag, got: %v", err)
		}
	})
	expectedContent := []string{
		"typemeta-gen - generate typemeta registration code",
		"Usage:",
		"go run typemeta-gen <-root=dir> [-help]",
		"Flags:",
		"-help",
		"-root",
	}
	output := stdout + stderr
	for _, content := range expectedContent {
		if !strings.Contains(output, content) {
			t.Errorf("Help output missing expected content: %s", content)
		}
	}
}

func TestRun_NoRootFlag(t *testing.T) {
	stdout, stderr := captureOutput(func() {
		err := run(false, "")
		if err == nil || !strings.Contains(err.Error(), "missing root flag") {
			t.Errorf("Expected error for missing root flag, got: %v", err)
		}
	})
	output := stdout + stderr
	if !strings.Contains(output, "Please provide a valid root to use") {
		t.Errorf("Expected output for missing root flag not found. Got: %s", output)
	}
}

func TestRun_InvalidDirectory(t *testing.T) {
	stdout, stderr := captureOutput(func() {
		err := run(false, "/nonexistent/directory")
		if err == nil || !strings.Contains(err.Error(), "no such file or directory") {
			t.Errorf("Expected error for invalid directory, got: %v", err)
		}
	})
	output := stdout + stderr
	if !strings.Contains(output, "Error: directory '/nonexistent/directory' does not exist") && !strings.Contains(output, "no such file or directory") {
		t.Errorf("Expected error message not found in output. Got: %s", output)
	}
}

func TestRun_InvalidDirectoryAccess(t *testing.T) {
	tmpDir, cleanup := setupTest(t)
	defer cleanup()
	if err := os.Chmod(tmpDir, 0000); err != nil {
		t.Fatalf("Failed to change directory permissions: %v", err)
	}
	defer os.Chmod(tmpDir, 0755)
	err := GenerateMetadata(tmpDir)
	if err == nil {
		t.Errorf("Expected error for directory access, got: %v", err)
	}
	if !strings.Contains(err.Error(), "permission denied") && !strings.Contains(err.Error(), "unable to generate metadata") {
		t.Errorf("Expected error message indicating permission denied or failure to read files, got: %v", err)
	}
}

func TestPrintHelp(t *testing.T) {
	stdout, stderr := captureOutput(printHelp)
	expectedContent := []string{
		"typemeta-gen - generate typemeta registration code",
		"Usage:",
		"go run typemeta-gen <-root=dir> [-help]",
		"Flags:",
		"-help",
		"-root",
	}
	output := stdout + stderr
	for _, content := range expectedContent {
		if !strings.Contains(output, content) {
			t.Errorf("Help output missing expected content: %s", content)
		}
	}
}

func TestGenerateMetadata(t *testing.T) {
	tmpDir, cleanup := setupTest(t)
	defer cleanup()

	// Create test files with metadata comments
	createTestFile(t, tmpDir, "test.go", `
package test

// +typemeta:table=users
type User struct {
	Name string
	Age  int
}
`)

	// Test successful generation
	err := GenerateMetadata(tmpDir)
	if err != nil {
		t.Errorf("GenerateMetadata failed: %v", err)
	}

	// Verify generated file exists
	genFile := filepath.Join(tmpDir, "typemeta_gen.go")
	if _, err := os.Stat(genFile); os.IsNotExist(err) {
		t.Error("Generated file was not created")
	}

	// Verify file contents
	content, err := os.ReadFile(genFile)
	if err != nil {
		t.Errorf("Failed to read generated file: %v", err)
	}

	expectedContent := []string{
		"// Code generated by typemeta-gen. DO NOT EDIT.",
		"package test",
		"import \"github.com/mike-jacks/typemeta\"",
		"func init() {",
		"typemeta.Register[User](\"table\", \"users\")",
	}

	contentStr := string(content)
	for _, expected := range expectedContent {
		if !strings.Contains(contentStr, expected) {
			t.Errorf("Generated file missing expected content: %s", expected)
		}
	}
}

func TestGenerateMetadata_InvalidMetadata(t *testing.T) {
	tmpDir, cleanup := setupTest(t)
	defer cleanup()

	// Create test file with invalid metadata format
	createTestFile(t, tmpDir, "test.go", `
package test

// +typemeta:invalid
type User struct {
	Name string
	Age  int
}
`)

	err := GenerateMetadata(tmpDir)
	if err == nil || !strings.Contains(err.Error(), "your +typemeta: syntax is incorrect") {
		t.Errorf("Expected error for invalid metadata format, got: %v", err)
	}
}

func TestGenerateMetadata_NoMetadata(t *testing.T) {
	tmpDir, cleanup := setupTest(t)
	defer cleanup()

	// Create test file without metadata comments
	createTestFile(t, tmpDir, "test.go", `
package test

type User struct {
	Name string
	Age  int
}
`)

	err := GenerateMetadata(tmpDir)
	if err != nil {
		t.Errorf("GenerateMetadata failed: %v", err)
	}

	// Verify no file was generated
	genFile := filepath.Join(tmpDir, "typemeta_gen.go")
	if _, err := os.Stat(genFile); !os.IsNotExist(err) {
		t.Error("Generated file was created when it shouldn't have been")
	}
}

func TestGenerateMetadata_MultipleFiles(t *testing.T) {
	tmpDir, cleanup := setupTest(t)
	defer cleanup()

	// Create multiple test files with metadata
	createTestFile(t, tmpDir, "user.go", `
package test

// +typemeta:table=users
type User struct {
	Name string
	Age  int
}
`)

	createTestFile(t, tmpDir, "post.go", `
package test

// +typemeta:table=posts
type Post struct {
	Title string
	Body  string
}
`)

	err := GenerateMetadata(tmpDir)
	if err != nil {
		t.Errorf("GenerateMetadata failed: %v", err)
	}

	// Verify generated file exists and contains both types
	genFile := filepath.Join(tmpDir, "typemeta_gen.go")
	if _, err := os.Stat(genFile); os.IsNotExist(err) {
		t.Error("Generated file was not created")
	}

	// Verify file contents
	content, err := os.ReadFile(genFile)
	if err != nil {
		t.Errorf("Failed to read generated file: %v", err)
	}

	contentStr := string(content)
	expectedTypes := []string{
		"typemeta.Register[User](\"table\", \"users\")",
		"typemeta.Register[Post](\"table\", \"posts\")",
	}

	for _, expected := range expectedTypes {
		if !strings.Contains(contentStr, expected) {
			t.Errorf("Generated file missing expected type: %s", expected)
		}
	}
}

func TestGenerateMetadata_WriteFileError(t *testing.T) {
	tmpDir, cleanup := setupTest(t)
	defer cleanup()

	// Create a test file with metadata comments
	createTestFile(t, tmpDir, "test.go", `
package test

// +typemeta:table=users
type User struct {
	Name string
	Age  int
}
`)

	// Make the output directory unwritable
	outputDir := filepath.Join(tmpDir, "output")
	if err := os.Mkdir(outputDir, 0755); err != nil {
		t.Fatalf("Failed to create output directory: %v", err)
	}
	if err := os.Chmod(outputDir, 0000); err != nil {
		t.Fatalf("Failed to change output directory permissions: %v", err)
	}
	defer os.Chmod(outputDir, 0755)

	// Run GenerateMetadata with the unwritable output directory
	err := GenerateMetadata(outputDir)
	if err == nil {
		t.Errorf("Expected error when writing file fails, got nil")
	}
	expectedError := "unable to access"
	if !strings.Contains(err.Error(), expectedError) {
		t.Errorf("Expected error message containing '%s', got: %v", expectedError, err)
	}
}

func TestRun_WithHelpFlag(t *testing.T) {
	stdout, stderr := captureOutput(func() {
		err := run(true, "")
		if err != nil {
			t.Errorf("Expected no error for help flag, got: %v", err)
		}
	})
	expectedContent := []string{
		"typemeta-gen - generate typemeta registration code",
		"Usage:",
		"go run typemeta-gen <-root=dir> [-help]",
		"Flags:",
		"-help",
		"-root",
	}
	output := stdout + stderr
	for _, content := range expectedContent {
		if !strings.Contains(output, content) {
			t.Errorf("Help output missing expected content: %s", content)
		}
	}
}

func TestRun_WithValidDirectory(t *testing.T) {
	tmpDir, cleanup := setupTest(t)
	defer cleanup()

	// Create a test file with metadata comments
	createTestFile(t, tmpDir, "test.go", `
package test

// +typemeta:table=users
type User struct {
	Name string
	Age  int
}
`)

	err := run(false, tmpDir)
	if err != nil {
		t.Errorf("Expected no error for valid directory, got: %v", err)
	}
}

func TestGenerateMetadata_WithInvalidFile(t *testing.T) {
	tmpDir, cleanup := setupTest(t)
	defer cleanup()

	// Create a test file with invalid metadata comments
	createTestFile(t, tmpDir, "test.go", `
package test

// +typemeta:invalid
type User struct {
	Name string
	Age  int
}
`)

	err := GenerateMetadata(tmpDir)
	if err == nil {
		t.Errorf("Expected error for invalid metadata, got nil")
	}
}

func TestMustWithLog_panicsOnMissingKeyAndLogs(t *testing.T) {
	typemeta.ResetRegistry()
	// Capture stdout
	old := os.Stdout
	r, w, _ := os.Pipe()
	os.Stdout = w
	defer func() {
		os.Stdout = old
	}()
	defer func() {
		w.Close()
	}()
	defer func() {
		if r := recover(); r == nil {
			t.Errorf("MustWithLog did not panic on missing key")
		}
		w.Close()
		var buf bytes.Buffer
		io.Copy(&buf, r)
		if !strings.Contains(buf.String(), "typemeta: missing metadata key") {
			t.Errorf("Expected log output for missing key, got: %s", buf.String())
		}
	}()
	typemeta.MustWithLog[TestUser]("missing")
}

type TestUser struct {
	Name string
	Age  int
}

func TestResetRegistry(t *testing.T) {
	typemeta.ResetRegistry()
	// Verify that the registry is empty
	typemeta.Register[TestUser]("table", "users")
	typemeta.ResetRegistry()
	value, ok := typemeta.Meta[TestUser]("table")
	if ok {
		t.Errorf("Expected registry to be empty, got value: %s", value)
	}
}

func TestRun_WithInvalidDirectory(t *testing.T) {
	err := run(false, "/nonexistent/directory")
	if err == nil {
		t.Errorf("Expected error for invalid directory, got nil")
	}
}

func TestGenerateMetadata_WithParsingError(t *testing.T) {
	tmpDir, cleanup := setupTest(t)
	defer cleanup()

	// Create a test file with invalid Go syntax
	createTestFile(t, tmpDir, "test.go", `
package test

// +typemeta:table=users
type User struct {
	Name string
	Age  int
	// Missing closing brace
`)

	err := GenerateMetadata(tmpDir)
	if err == nil {
		t.Errorf("Expected error for parsing error, got nil")
	}
}

func TestGenerateMetadata_WithWriteError(t *testing.T) {
	tmpDir, cleanup := setupTest(t)
	defer cleanup()

	// Create a test file with metadata comments
	createTestFile(t, tmpDir, "test.go", `
package test

// +typemeta:table=users
type User struct {
	Name string
	Age  int
}
`)

	// Make the output directory unwritable
	outputDir := filepath.Join(tmpDir, "output")
	if err := os.Mkdir(outputDir, 0755); err != nil {
		t.Fatalf("Failed to create output directory: %v", err)
	}
	if err := os.Chmod(outputDir, 0000); err != nil {
		t.Fatalf("Failed to change output directory permissions: %v", err)
	}
	defer os.Chmod(outputDir, 0755)

	err := GenerateMetadata(outputDir)
	if err == nil {
		t.Errorf("Expected error when writing file fails, got nil")
	}
}
