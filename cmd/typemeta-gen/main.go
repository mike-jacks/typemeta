package main

import (
	"bytes"
	"errors"
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"strings"
)

const MODULE_NAME = "github.com/mike-jacks/typemeta"

var (
	helpFlag    = flag.Bool("help", false, "Show help message. Default: 'false'")
	rootDirFlag = flag.String("root", "", "Root directory to scan for Go files. Default: ''. (Required)")
)

func main() {
	flag.Parse()

	if *helpFlag {
		printHelp()
		return
	}

	if *rootDirFlag == "" {
		fmt.Println("Please provide a valid root to use")
		fmt.Println()
		flag.PrintDefaults()
		return
	}

	if _, err := os.Stat(*rootDirFlag); os.IsNotExist(err) {
		fmt.Printf("Error: directory '%s' does not exist", *rootDirFlag)
		os.Exit(1)
	} else if err != nil {
		fmt.Printf("Error accessing directory '%s': %v", *rootDirFlag, err)
		os.Exit(1)
	}

	log.Println("Running typemeta-gen...")
	if err := GenerateMetadata(*rootDirFlag); err != nil {
		log.Fatal(err)
	}
}

func printHelp() {
	fmt.Println("typemeta-gen - generate typemeta registration code")
	fmt.Println("\nUsage:")
	fmt.Println("  go run typemeta-gen <-root=dir> [-help]")
	fmt.Println("\nFlags:")
	flag.PrintDefaults()
}

func GenerateMetadata(root string) error {
	packageBuffers := make(map[string]*bytes.Buffer)
	codeAddedInDir := make(map[string]bool)

	err := filepath.Walk(root, func(path string, info os.FileInfo, err error) error {
		if err != nil || strings.HasSuffix(path, "_test.go") || !strings.HasSuffix(path, ".go") {
			return nil
		}

		fset := token.NewFileSet()
		fileNode, err := parser.ParseFile(fset, path, nil, parser.ParseComments)
		if err != nil {
			return fmt.Errorf("failed to parse file %s: %w", path, err)
		}

		dir := filepath.Dir(path)
		pkgName := fileNode.Name.Name

		buf, ok := packageBuffers[dir]
		if !ok {
			buf = &bytes.Buffer{}
			fmt.Fprintln(buf, "// Code generated by typemeta-gen. DO NOT EDIT.")
			fmt.Fprintf(buf, "package %s\n\n", pkgName)
			fmt.Fprintf(buf, "import \"%s\"\n\n", MODULE_NAME)
			fmt.Fprintln(buf, "func init() {")
			packageBuffers[dir] = buf
		}

		for _, decl := range fileNode.Decls {
			gen, ok := decl.(*ast.GenDecl)
			if !ok || gen.Tok != token.TYPE {
				continue
			}

			for _, spec := range gen.Specs {
				ts, ok := spec.(*ast.TypeSpec)
				if !ok {
					continue
				}
				if _, ok := ts.Type.(*ast.StructType); !ok {
					continue
				}

				typeName := ts.Name.Name

				if gen.Doc != nil {
					for _, comment := range gen.Doc.List {
						line := strings.TrimSpace(strings.TrimPrefix(comment.Text, "//"))
						if strings.HasPrefix(line, "+typemeta:") {
							parts := strings.SplitN(strings.TrimPrefix(line, "+typemeta:"), "=", 2)
							if len(parts) == 2 {
								key := strings.TrimSpace(parts[0])
								value := strings.TrimSpace(parts[1])
								fmt.Fprintf(buf, "\ttypemeta.Register[%s](\"%s\", \"%s\")\n", typeName, key, value)
								codeAddedInDir[dir] = true
							} else {
								msg := fmt.Sprintf("your +typemeta: syntax is incorrect. You entered this: '// %s'. Valid Example: '// +typemeta:key=value'\n", line)
								log.Print(msg)
								return errors.New(msg)
							}
						}
					}
				}
			}
		}
		return nil
	})
	if err != nil {
		return fmt.Errorf("unable to generate metadata: %w", err)
	}

	// Write out files
	for dir, buf := range packageBuffers {
		if codeAddedInDir[dir] {
			fmt.Fprintln(buf, "}")
			outputPath := filepath.Join(dir, "typemeta_gen.go")
			err := os.WriteFile(outputPath, buf.Bytes(), 0o644)
			if err != nil {
				return fmt.Errorf("writing file for package %s: %w", outputPath, err)
			}
			log.Printf("Generated: %s\n", outputPath)
		}
	}
	return nil
}
