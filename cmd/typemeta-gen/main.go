package main

import (
	"bytes"
	"errors"
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"strings"
)

const MODULE_NAME = "github.com/mike-jacks/typemeta"

func run(helpFlag bool, rootDirFlag string) error {
	if helpFlag {
		printHelp()
		return nil
	}

	if rootDirFlag == "" {
		fmt.Println("Please provide a valid root to use")
		fmt.Println()
		flag.PrintDefaults()
		return fmt.Errorf("missing root flag")
	}

	if _, err := os.Stat(rootDirFlag); os.IsNotExist(err) {
		fmt.Printf("Error: directory '%s' does not exist", rootDirFlag)
		return err
	} else if err != nil {
		fmt.Printf("Error accessing directory '%s': %v", rootDirFlag, err)
		return err
	}

	log.Println("Running typemeta-gen...")
	if err := GenerateMetadata(rootDirFlag); err != nil {
		log.Print(err)
		return err
	}
	return nil
}

func main() {
	helpFlag := flag.Bool("help", false, "Show help message. Default: 'false'")
	rootDirFlag := flag.String("root", "", "Root directory to scan for Go files. Default: ''. (Required)")
	flag.Parse()
	if err := run(*helpFlag, *rootDirFlag); err != nil {
		os.Exit(1)
	}
}

func printHelp() {
	fmt.Println("typemeta-gen - generate typemeta registration code")
	fmt.Println("\nUsage:")
	fmt.Println("  go run typemeta-gen <-root=dir> [-help]")
	fmt.Println("\nFlags:")
	flag.PrintDefaults()
}

func GenerateMetadata(root string) error {
	// Check if the directory is readable
	if _, err := os.Stat(root); err != nil {
		return fmt.Errorf("unable to access directory: %v", err)
	}

	packageBuffers := make(map[string]*bytes.Buffer)
	codeAddedInDir := make(map[string]bool)

	err := filepath.Walk(root, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			// If we can't stat the file or directory, return the error
			return fmt.Errorf("unable to access %s: %v", path, err)
		}
		if strings.HasSuffix(path, "_test.go") || !strings.HasSuffix(path, ".go") {
			return nil
		}

		// Check if the file is readable
		if _, err := os.Stat(path); err != nil {
			return fmt.Errorf("unable to access file %s: %v", path, err)
		}

		fset := token.NewFileSet()
		fileNode, err := parser.ParseFile(fset, path, nil, parser.ParseComments)
		if err != nil {
			return fmt.Errorf("failed to parse file %s: %w", path, err)
		}

		dir := filepath.Dir(path)
		pkgName := fileNode.Name.Name

		buf, ok := packageBuffers[dir]
		if !ok {
			buf = &bytes.Buffer{}
			fmt.Fprintln(buf, "// Code generated by typemeta-gen. DO NOT EDIT.")
			fmt.Fprintf(buf, "package %s\n\n", pkgName)
			fmt.Fprintf(buf, "import \"%s\"\n\n", MODULE_NAME)
			fmt.Fprintln(buf, "func init() {")
			packageBuffers[dir] = buf
		}

		for _, decl := range fileNode.Decls {
			gen, ok := decl.(*ast.GenDecl)
			if !ok || gen.Tok != token.TYPE {
				continue
			}

			for _, spec := range gen.Specs {
				ts, ok := spec.(*ast.TypeSpec)
				if !ok {
					continue
				}
				if _, ok := ts.Type.(*ast.StructType); !ok {
					continue
				}

				typeName := ts.Name.Name

				if gen.Doc != nil {
					for _, comment := range gen.Doc.List {
						line := strings.TrimSpace(strings.TrimPrefix(comment.Text, "//"))
						if strings.HasPrefix(line, "+typemeta:") {
							keyValues := strings.TrimPrefix(line, "+typemeta:")
							for _, keyValue := range strings.Split(keyValues, ",") {
								parts := strings.SplitN(strings.TrimSpace(keyValue), "=", 2)
								if len(parts) == 2 {
									key := strings.TrimSpace(parts[0])
									value := strings.TrimSpace(parts[1])
									fmt.Fprintf(buf, "\ttypemeta.Register[%s](\"%s\", \"%s\")\n", typeName, key, value)
									codeAddedInDir[dir] = true
								} else {
									msg := fmt.Sprintf("your +typemeta: syntax is incorrect. You entered this: '// %s'. Valid Example: '// +typemeta:key=value'\n", line)
									log.Print(msg)
									return errors.New(msg)
								}
							}
						}
					}
				}
			}
		}
		return nil
	})
	if err != nil {
		return fmt.Errorf("unable to generate metadata: %w", err)
	}

	// Write out files
	for dir, buf := range packageBuffers {
		if codeAddedInDir[dir] {
			fmt.Fprintln(buf, "}")
			outputPath := filepath.Join(dir, "typemeta_gen.go")
			err := os.WriteFile(outputPath, buf.Bytes(), 0o644)
			if err != nil {
				return fmt.Errorf("writing file for package %s: %w", outputPath, err)
			}
			log.Printf("Generated: %s\n", outputPath)
		}
	}
	return nil
}
